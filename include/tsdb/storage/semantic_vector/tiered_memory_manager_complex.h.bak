#ifndef TSDB_STORAGE_SEMANTIC_VECTOR_TIERED_MEMORY_MANAGER_H_
#define TSDB_STORAGE_SEMANTIC_VECTOR_TIERED_MEMORY_MANAGER_H_

#include <memory>
#include <vector>
#include <string>
#include <map>
#include <optional>
#include <shared_mutex>
#include <unordered_map>

#include "tsdb/core/semantic_vector_types.h"
#include "tsdb/core/semantic_vector_config.h"
#include "tsdb/storage/semantic_vector_architecture.h"
#include "tsdb/core/result.h"
#include "tsdb/core/error.h"

namespace tsdb {
namespace storage {
namespace semantic_vector {

// ============================================================================
// MEMORY MANAGER COMPONENT HEADER
// ============================================================================

/**
 * @brief Memory Manager Component for Tiered Memory Management
 * 
 * This component provides tiered memory management, adaptive memory allocation,
 * and memory optimization capabilities for semantic vector storage operations.
 * 
 * DESIGN HINTS:
 * - Use tiered memory architecture (RAM, SSD, HDD) for optimal performance
 * - Implement adaptive memory allocation with defragmentation
 * - Support memory pressure detection and automatic optimization
 * - Enable memory pooling for efficient allocation patterns
 * - Use memory compression for data that can be compressed
 * - Implement memory monitoring and alerting for resource management
 * - Support memory migration between tiers based on access patterns
 * 
 * PERFORMANCE EXPECTATIONS:
 * - Memory allocation latency: < 0.1ms for small allocations
 * - Memory migration latency: < 10ms for tier transitions
 * - Memory compression ratio: 50% reduction for compressible data
 * - Memory defragmentation: < 100ms for 1GB memory pool
 * - Memory monitoring overhead: < 1% of total memory usage
 * - Tier promotion/demotion: < 5ms per operation
 * 
 * IMPLEMENTATION GUIDANCE:
 * - Use unified memory optimization types from TASK-1 for consistency
 * - Implement memory optimization using unified memory types
 * - Follow performance contracts from TASK-4 interfaces
 * - Use configuration from TASK-2 for flexible deployment
 * - Integrate with operating system memory management
 * - Implement circuit breaker patterns for error handling
 * - Add comprehensive performance monitoring and metrics
 * 
 * INTEGRATION NOTES:
 * - Integrates with ITieredMemoryManager and IAdaptiveMemoryPool interfaces from TASK-4
 * - Uses unified TieredMemoryPolicy, MemoryOptimizationConfig types from TASK-1
 * - Follows memory optimization strategies from TASK-2
 * - Supports AdvancedStorage operations from TASK-5
 * - Enables seamless integration with existing storage operations
 */

/**
 * @brief Tiered Memory Manager Implementation
 * 
 * Implements the ITieredMemoryManager interface with tiered memory management,
 * access pattern tracking, and automatic memory optimization.
 */
class TieredMemoryManagerImpl {
public:
    /**
     * @brief Constructor with configuration
     * 
     * DESIGN HINT: Initialize tiered memory structures and access tracking
     * to support optimal memory placement and automatic optimization.
     * 
     * PERFORMANCE HINT: Pre-allocate memory pools for each tier to avoid
     * frequent memory allocations during tier transitions.
     */
    explicit TieredMemoryManagerImpl(const core::semantic_vector::SemanticVectorConfig::MemoryConfig& config);
    
    virtual ~TieredMemoryManagerImpl() = default;
    
    // ============================================================================
    // MEMORY TIER MANAGEMENT
    // ============================================================================
    
    /**
     * @brief Add series to specific memory tier
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Allocate memory in specified tier efficiently
     * - Initialize access tracking for the series
     * - Update tier statistics and capacity tracking
     * - Handle tier capacity limits gracefully
     * - Support concurrent access safely
     * 
     * PERFORMANCE TARGETS:
     * - Add latency: < 1ms per series
     * - Memory overhead: < 1% of series data size
     * - Throughput: > 10,000 series/second for batch operations
     * - Tier capacity utilization: > 90% before promotion
     */
    core::Result<void> add_series(const core::SeriesID& series_id, core::semantic_vector::MemoryTier tier);
    
    /**
     * @brief Promote series to higher memory tier
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Migrate data to higher tier efficiently
     * - Update access patterns and statistics
     * - Handle tier capacity constraints
     * - Optimize migration for minimal latency impact
     * 
     * PERFORMANCE TARGETS:
     * - Promotion latency: < 5ms per series
     * - Data migration: < 10ms for 1MB data
     * - Tier transition overhead: < 2% of data size
     */
    core::Result<void> promote_to_tier(const core::SeriesID& series_id, core::semantic_vector::TieredMemoryPolicy::Tier tier) override;
    
    /**
     * @brief Demote series to lower memory tier
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Migrate data to lower tier efficiently
     * - Update access patterns and statistics
     * - Handle tier capacity constraints
     * - Optimize migration for minimal latency impact
     * 
     * PERFORMANCE TARGETS:
     * - Demotion latency: < 5ms per series
     * - Data migration: < 10ms for 1MB data
     * - Tier transition overhead: < 2% of data size
     */
    core::Result<void> demote_from_tier(const core::SeriesID& series_id) override;
    
    /**
     * @brief Get current tier for series
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Efficient tier lookup for series
     * - Support tier history tracking
     * - Cache frequently accessed tier information
     * 
     * PERFORMANCE TARGETS:
     * - Tier lookup: < 0.1ms per query
     * - Tier accuracy: > 99% for current tier
     */
    core::Result<core::semantic_vector::TieredMemoryPolicy::Tier> get_tier(const core::SeriesID& series_id) const override;
    
    // ============================================================================
    // MEMORY ACCESS OPERATIONS
    // ============================================================================
    
    /**
     * @brief Record series access for tier optimization
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Track access frequency and patterns
     * - Update access statistics for tier decisions
     * - Support access pattern analysis
     * - Handle concurrent access tracking
     * 
     * PERFORMANCE TARGETS:
     * - Access tracking: < 0.01ms per access
     * - Pattern analysis: < 1ms per analysis
     * - Memory overhead: < 0.1% of total memory
     */
    core::Result<void> access_series(const core::SeriesID& series_id) override;
    
    /**
     * @brief Get access frequency for series
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Calculate access frequency efficiently
     * - Support time-based frequency windows
     * - Handle frequency decay over time
     * 
     * PERFORMANCE TARGETS:
     * - Frequency calculation: < 0.1ms per query
     * - Frequency accuracy: > 95% for recent accesses
     */
    core::Result<double> get_access_frequency(const core::SeriesID& series_id) const override;
    
    /**
     * @brief Get all series in specific tier
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Efficient series enumeration per tier
     * - Support tier filtering and sorting
     * - Handle large tier populations
     * 
     * PERFORMANCE TARGETS:
     * - Series enumeration: < 1ms for 1,000 series
     * - Tier filtering: < 0.5ms per filter
     */
    core::Result<std::vector<core::SeriesID>> get_series_in_tier(core::semantic_vector::TieredMemoryPolicy::Tier tier) const override;
    
    // ============================================================================
    // MEMORY OPTIMIZATION OPERATIONS
    // ============================================================================
    
    /**
     * @brief Optimize memory usage across tiers
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Analyze access patterns for optimization
     * - Perform automatic tier promotions/demotions
     * - Handle memory pressure and capacity constraints
     * - Optimize for overall system performance
     * 
     * PERFORMANCE TARGETS:
     * - Optimization time: < 100ms for 1GB memory
     * - Memory efficiency improvement: > 10%
     * - Performance impact: < 5% during optimization
     */
    core::Result<void> optimize_memory_usage() override;
    
    /**
     * @brief Defragment memory pools
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Identify memory fragmentation patterns
     * - Consolidate fragmented memory blocks
     * - Optimize memory layout for better cache locality
     * - Handle defragmentation safely
     * 
     * PERFORMANCE TARGETS:
     * - Defragmentation time: < 100ms for 1GB memory
     * - Fragmentation reduction: > 50%
     * - Performance improvement: > 5% after defragmentation
     */
    core::Result<void> defragment_memory() override;
    
    /**
     * @brief Get memory usage for specific tier
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Calculate accurate memory usage per tier
     * - Include overhead and metadata in calculations
     * - Support real-time memory monitoring
     * 
     * PERFORMANCE TARGETS:
     * - Usage calculation: < 1ms per tier
     * - Usage accuracy: > 99% of actual memory usage
     */
    core::Result<size_t> get_memory_usage(core::semantic_vector::TieredMemoryPolicy::Tier tier) const override;
    
    /**
     * @brief Get total memory usage across all tiers
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Aggregate memory usage across all tiers
     * - Include management overhead in total
     * - Support memory usage trends and analysis
     * 
     * PERFORMANCE TARGETS:
     * - Total calculation: < 5ms for all tiers
     * - Total accuracy: > 99% of actual memory usage
     */
    core::Result<size_t> get_total_memory_usage() const override;
    
    // ============================================================================
    // POLICY MANAGEMENT
    // ============================================================================
    
    /**
     * @brief Update tiered memory policy
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Apply new policy settings safely
     * - Rebalance memory across tiers if needed
     * - Update promotion/demotion thresholds
     * - Maintain policy consistency
     * 
     * PERFORMANCE TARGETS:
     * - Policy update: < 10ms for policy changes
     * - Rebalancing: < 100ms for 1GB memory
     * - Policy consistency: > 99% compliance
     */
    core::Result<void> update_policy(const core::semantic_vector::TieredMemoryPolicy& policy) override;
    
    /**
     * @brief Get current tiered memory policy
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Return current policy state
     * - Include runtime modifications
     * - Support policy validation
     * 
     * PERFORMANCE TARGETS:
     * - Policy retrieval: < 0.1ms per query
     * - Policy accuracy: > 99% of current state
     */
    core::Result<core::semantic_vector::TieredMemoryPolicy> get_policy() const override;
    
    // ============================================================================
    // PERFORMANCE MONITORING
    // ============================================================================
    
    /**
     * @brief Get tiered memory metrics
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Collect comprehensive tiered memory metrics
     * - Include promotion/demotion statistics
     * - Track access patterns and performance
     * - Support real-time monitoring
     * 
     * PERFORMANCE TARGETS:
     * - Metrics collection: < 1ms for all metrics
     * - Metrics accuracy: > 99% of actual values
     */
    core::Result<core::semantic_vector::TieredMemoryPolicy::Metrics> get_metrics() const override;
    
    /**
     * @brief Reset tiered memory metrics
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Reset all performance counters
     * - Clear historical metrics
     * - Maintain policy and configuration
     * - Log reset events for monitoring
     */
    core::Result<void> reset_metrics() override;
    
    // ============================================================================
    // CONFIGURATION MANAGEMENT
    // ============================================================================
    
    /**
     * @brief Update memory configuration
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Validate new configuration using unified validation
     * - Apply configuration changes safely
     * - Rebalance memory if necessary
     * - Maintain backward compatibility
     * - Log configuration changes for audit
     */
    void update_config(const core::semantic_vector::SemanticVectorConfig::MemoryConfig& config) override;
    
    /**
     * @brief Get current memory configuration
     * 
     * IMPLEMENTATION GUIDANCE:
     * - Return current configuration state
     * - Include runtime modifications
     * - Provide configuration validation status
     * - Support configuration export for backup
     */
    core::semantic_vector::SemanticVectorConfig::MemoryConfig get_config() const override;

private:
    // ============================================================================
    // PRIVATE IMPLEMENTATION DETAILS
    // ============================================================================
    
    /**
     * @brief Internal tiered memory structures
     * 
     * DESIGN HINT: Use efficient data structures for tiered memory management:
     * - Tier-specific memory pools for efficient allocation
     * - Access pattern tracking for optimization
     * - Memory migration engine for tier transitions
     * - Policy engine for automated management
     */
    struct TieredMemoryStructures {
        // Tier-specific memory pools
        std::unique_ptr<class RAMMemoryPool> ram_pool;
        std::unique_ptr<class SSDMemoryPool> ssd_pool;
        std::unique_ptr<class HDDMemoryPool> hdd_pool;
        
        // Access pattern tracker
        std::unique_ptr<class AccessPatternTracker> access_tracker;
        
        // Memory migration engine
        std::unique_ptr<class MemoryMigrationEngine> migration_engine;
        
        // Policy engine for automated management
        std::unique_ptr<class TieredMemoryPolicyEngine> policy_engine;
        
        // Memory monitoring and alerting
        std::unique_ptr<class MemoryMonitor> memory_monitor;
    };
    
    /**
     * @brief Performance monitoring structures
     * 
     * DESIGN HINT: Track comprehensive performance metrics for all tiered memory operations
     * to enable optimization and monitoring.
     */
    struct PerformanceMonitoring {
        // Tier management metrics
        std::atomic<size_t> total_promotions{0};
        std::atomic<size_t> total_demotions{0};
        std::atomic<double> average_promotion_time_ms{0.0};
        std::atomic<double> average_demotion_time_ms{0.0};
        
        // Memory usage metrics
        std::atomic<size_t> ram_usage_bytes{0};
        std::atomic<size_t> ssd_usage_bytes{0};
        std::atomic<size_t> hdd_usage_bytes{0};
        std::atomic<double> average_access_time_ms{0.0};
        
        // Performance metrics
        std::atomic<double> cache_hit_ratio{0.0};
        std::atomic<size_t> total_memory_operations{0};
        std::atomic<double> memory_optimization_time_ms{0.0};
        std::atomic<double> defragmentation_time_ms{0.0};
        
        // Additional metrics used in implementation
        std::atomic<double> average_allocation_latency_ms{0.0};
        std::atomic<double> average_access_latency_ms{0.0};
        std::atomic<size_t> total_allocations{0};
        std::atomic<size_t> total_deallocations{0};
        std::atomic<size_t> total_migrations{0};
        std::atomic<size_t> total_memory_usage_bytes{0};
        std::atomic<double> memory_efficiency_ratio{1.0};
        
        // Error tracking
        std::atomic<size_t> memory_allocation_errors{0};
        std::atomic<size_t> migration_errors{0};
        std::atomic<size_t> optimization_errors{0};
        std::atomic<size_t> allocation_errors{0};
    };
    
    // Configuration and state
    core::semantic_vector::SemanticVectorConfig::MemoryConfig config_;
    TieredMemoryStructures tiered_structures_;
    PerformanceMonitoring performance_monitoring_;
    mutable std::shared_mutex mutex_;
    
    // Internal implementation structures
    std::vector<std::unique_ptr<class TierAllocator>> tier_allocators_;
    std::unordered_map<core::SeriesID, struct MemoryAllocation> allocations_;
    std::unique_ptr<class AccessPatternTracker> access_tracker_;
    std::unique_ptr<class MemoryMigrationEngine> migration_engine_;
    
    // Internal helper methods
    core::Result<void> initialize_tiered_memory_structures();
    core::Result<void> validate_series_id(const core::SeriesID& series_id) const;
    core::Result<void> update_access_patterns(const core::SeriesID& series_id);
    core::Result<void> perform_automatic_optimization();
    core::Result<void> update_performance_metrics(const std::string& operation, double latency, bool success) const;
};

// ============================================================================
// FACTORY AND UTILITY FUNCTIONS
// ============================================================================

/**
 * @brief Create tiered memory manager instance
 * 
 * IMPLEMENTATION GUIDANCE:
 * - Use factory pattern for flexible instantiation
 * - Support different tier configurations for different use cases
 * - Validate configuration before creation
 * - Provide default configurations for common scenarios
 */
std::unique_ptr<ITieredMemoryManager> CreateTieredMemoryManager(
    const core::semantic_vector::SemanticVectorConfig::MemoryConfig& config);

/**
 * @brief Create memory manager for specific use case
 * 
 * IMPLEMENTATION GUIDANCE:
 * - Provide optimized configurations for common use cases
 * - Support high-performance, memory-efficient, and high-accuracy modes
 * - Validate use case requirements
 * - Provide configuration recommendations
 */
std::unique_ptr<ITieredMemoryManager> CreateTieredMemoryManagerForUseCase(
    const std::string& use_case,  // "high_performance", "memory_efficient", "high_accuracy"
    const core::semantic_vector::SemanticVectorConfig::MemoryConfig& base_config = core::semantic_vector::SemanticVectorConfig::MemoryConfig());

/**
 * @brief Validate memory manager configuration
 * 
 * IMPLEMENTATION GUIDANCE:
 * - Validate all configuration parameters
 * - Check for conflicts and inconsistencies
 * - Provide detailed error messages and suggestions
 * - Support configuration optimization recommendations
 */
core::Result<core::semantic_vector::ConfigValidationResult> ValidateTieredMemoryManagerConfig(
    const core::semantic_vector::SemanticVectorConfig::MemoryConfig& config);

} // namespace semantic_vector
} // namespace storage
} // namespace tsdb

#endif // TSDB_STORAGE_SEMANTIC_VECTOR_TIERED_MEMORY_MANAGER_H_ 